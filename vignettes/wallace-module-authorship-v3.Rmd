---
title: "How to write a Wallace module"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

### 1. Come up with an ID for the new module. 
#### The ID must be unique (there cannot be two modules with the same ID) and can only contain English letters, digits, and underscores.

For this example, we will add a module that calculates and prints pairwise variable correlations using Pearson's product-moment correlation coefficient. 
We will name this module simply "correlations". 

Each module will be built in several files: `<id>.yml`, `<id>.md`, `<id>.R`, and *optionally* `<id>.Rmd`.

To begin, use the `wallace::create_module()` function to generate the template files for a new module. Fill the arguments as follows

    - id, or module name, will be "correlations"
    - dir, or module directory will be "./inst/shiny/modules"
    - map, boolean; will the module require modifying the map?
    - result, boolean; will the module show anything in the *results* tab?
    - rmd, boolean; will the module report anything in the session code download?
    - save, boolean; will the module save custom data when the user saves the current session?

```{r, eval = F}
wallace::create_module(id = "correlations", dir = "./inst/shiny/custom_modules", map = F, result = T, rmd = F, save = F)
```

### Edit the four new files created in the ./custom_modules directory
Four new files will be created in the ./custom_modules directory: correlations.yml, correlations.md, correlations.R and optionally correlations.Rmd.

2. Open the YAML file named `correlations.yml` and set the following parameters:

    - component: Which component this module belongs to (one of: occs, envs, poccs, penvs, espace, part, model, vis, proj)
    - short_name: The label to show beside the radio button in the component's UI
    - long_name: A longer name for the module, to show as the title in the UI
    - authors: The author or authors of this module
    - package: The R package that is used by this module
    
```{r, eval = F}
component: "penvs"
short_name: "Pearson's correlations"
long_name: "Calculate pairwise Pearson's correlations between environmental layers"
authors: "P. Galante"
package: [dismo]
```

3. In the same directory as the YAML file, you need to have a markdown file named `correlations.md` that contains instructions for this module.
Enter the background information for the module, as well as how the module will be used

```{}
### **Module:**

**BACKGROUND**

Calculate pairwise Pearson's product-moment variable correlations for all predictor variables. 

**IMPLEMENTATION**

After loading environmental layers select background extent and sample background points. These points are used to sample each layer to calculate correlations. Correlations are calculated for single or multiple species.

**REFERENCES**

Robert J. Hijmans (2019). raster: Geographic Data Analysis and Modeling. R package version 2.9-5.

```


4. In the same directory as the YAML and md files, you need to have an R file named `correlations.R` with the source code used in the module. This R file to contains the skeleton of:

    - A function named `correlations_module_ui` that returns the UI for this module.
    This function should follow the conventions for general Shiny modules - it
    should take a single argument, and use it to namespace all its UI. The UI
    needs to be returned from the function. There should usually be some sort
    of a "Run" button.
    
```{r, eval = F}
correlations_module_ui <- function(id) {
  ns <- shiny::NS(id)
  tagList(
    # UI
    ## Add a checkbox for batch processing (more than 1 species)
    checkboxInput(ns("batch1"), label = strong("Batch"), value = T),
    ## Give the action button a name and a label.
    actionButton(ns("runCorrs"), label = "Calculate correlations"),
    ## UI for reselecting variables after calculating correlations
    uiOutput(ns("VarSelect")),
    actionButton(ns("selectConfirm"), label = "Select Variables")
    )
}
```
    
    - A function named `correlations_module_server` that defines the server for this module.
    This function should follow the conventions for general Shiny modules - it
    should take `input`, `output`, and `session` as parameters, as well as one
    extra parameter named `common`.
    
The `common` variable supplied to a module's server and map function is a list containing:
  - The following reactive variables that can be used by the module: logger, spp, curSp, allSp, curEnv, curModel, component, module, envs.global, mapCntr
  - The following reactives that are shortcuts to reactives inside spp: occs, envs, bg, bgExt, bgMask, evalOut, mapPred, mapProj, rmm
  - A function `update_component(tab)` that allows you to switch to a new tab within the component
  - A function `remove_module(component, module)` to remove a specific module from the UI
  
```{r, eval = F}
correlations_module_server <- function(input, output, session, common) {
  ## Define common objects that will be used in this function
  logger <- common$logger
  spp    <- common$spp
  allSp  <- common$allSp
  curSp  <- common$curSp
  bgMask <- common$bgMask # raster stack after masking by background
  VarSelector <- common$VarSelector

  output$VarSelect <- renderUI({
    req(bgMask())
    shinyWidgets::pickerInput(
      "VarSelector",
      label = "Select variables (**)",
      choices = setNames(as.list(names(bgMask())), names(bgMask())),
      multiple = TRUE,
      selected = names(bgMask()),
      options = list(`actions-box` = TRUE))
  })

  ## When action button defined in the ui function above is clicked, do the following:
  observeEvent(input$runCorrs, {
    # Check that the background has already been selected
    req(bgMask())
    
    # Set up if you want batch to be allowed
      # allSp() is the list of species selected
      # curSp() refers to the currently selected species in the GUI
    if (input$batch1 == TRUE) spLoop <- allSp() else spLoop <- curSp()
    # If batch is true, loop through all species (allSp())
    for (sp in spLoop){
    # FUNCTION CALL ####
      smartProgress(logger, message = "Calculating pairwise correlations", {envCorrs <- raster::layerStats(x = spp[[sp]]$procEnvs$bgMask, na.rm = T, stat = "pearson")})
    # To update the log window
    logger %>% writeLog(hlSpp(em(sp)), "Finished calculating correlations")
    #envCorrs <- raster::layerStats(x = bgMask(), na.rm = T, stat = "pearson")

    # LOAD INTO SPP ####
  spp[[sp]]$procEnvs$envCorrs <- envCorrs$`pearson correlation coefficient`
    # METADATA ####
  }
  # Switch to Results tab to display results
  common$update_component(tab = "Results")
  })

  # Define output as a table
  output$envCorrTable <- renderText({
    # Result
    knitr::kable(spp[[curSp()]]$procEnvs$envCorrs, format = 'html')
  })

  ## Observe when selection is confirmed
  observeEvent(input$selectConfirm, {
    req(spp[[curSp()]]$procEnvs$envCorrs)

    ## update bg object
    spp[[curSp()]]$procEnvs$bgMask <- spp[[curSp()]]$procEnvs$bgMask[[VarSelector()]]

    # Add a line to logger to identify which variables were selected
        # hlSpp() prints the species name in green, bold, and italics
    logger %>% writeLog(hlSpp(em(curSp())), "Selected: ", paste0(names(spp[[curSp()]]$procEnvs$bgMask), collapse = ", "))
  })
}
```

Two lines in the file server.R need to be updated:
The component controls (here, COMPONENT: OBTAIN ENVIRONMENTAL DATA), and  to create a shortcut to values nested inside common list (METADATA FUNCTIONALITY).

The server.R file is found at **./inst/shiny/server.R**
```{r, eval = F}
VarSelector <- reactive(input$VarSelector)
```

```{r, eval = F}
VarSelector = VarSelector,
```
  
    - *OPTIONAL:* A function named `correlations_module_result` that returns the UI for the
    results section of the module. This function should follow the conventions
    for Shiny modules - it should take a single argument, and use it to namespace
    all its UI. Any outputs need to be rendered in the `<id>_module_server` function.
    
    We call the results function "envCorrTable" from the server function, above.
    
```{r, eval = F}
correlations_module_result <- function(id) {
  ns <- NS(id)
  #spp <- common$spp
  #curSp <- common$curSp
  # Result UI as html
  htmlOutput(ns("envCorrTable"))
}
```

    - *OPTIONAL:* A function named `correlations_module_map` that modifies the map. This
    function takes two arguments: `map` (a reference to a leaflet map) and
    `common` (the same parameter that is given to the server function - see below for details).
```{r, eval = F}
correlations_module_rmd <- function(species) {
  # Variables used in the module's Rmd code
  list(
    module_knit = species$rmm$code$wallaceSettings$someFlag,
    var1 = species$rmm$code$wallaceSettings$someSetting1,
    var2 = species$rmm$code$wallaceSettings$someSetting2
  )
}
```
    
    - *OPTIONAL:* A function named `<id>_module_rmd` that returns a list with
    variables that are used in the module's Rmd code. This function takes an
    argument `species` that contains all the information for the current species.
    - *OPTIONAL:* The `<id>_module_server` function can return a list with two
    functions `save()` and `load(state)`, if you want the module to be able to
    record some information when the state of the session is saved. The `save()`
    function takes no arguments and should return a named list with all the
    variables to save. The `load(state)` function takes one argument, which will
    contain the same list of variables that was saved, and it should take 
    the necessary steps to load the information back into the module.

5. *OPTIONAL:* If the module should add some code to the Session Code download,
you need to create a file `<id>.Rmd` in the same directory. This file should 
contain Rmd code to repeat the step this module performs. If you need to use any
variables in the code, you can wrap the variables in double curly braces (for
example `{{num_observations}}`) and define them using the `correlations_module_rmd`
function metioned above. Two variables are always made automatically available
for these Rmd code chunks: `{{sp}}` is the species ID and `{{spName}}` is the
species' scientific name. 

## 6. After creating a module, you need to tell the Wallace app to use your new module. You do this by calling the function
```{r}
wallace::register_module(register_module("./inst/shiny/custom_modules/correlations.yml"))
```
